#include "iarduino_I2C_4LED.h"																									//
																																//
//		Инициализация модуля:																									//	Возвращаемое значение: результат инициализации.
bool	iarduino_I2C_4LED::begin			(void){																				//	Параметр: отсутствует
		//	Инициируем работу с шиной I2C:																						//
			objI2C->begin(100);																									//	Инициируем передачу данных по шине I2C на скорости 100 кГц.
		//	Если адрес не указан, то ищим модуль на шине I2C:																	//
			if(valAddrTemp==0){																									//
				for(int i=1; i<127; i++){																						//	Проходим по всем адресам на шине I2C
					if( objI2C->checkAddress(i)											){	valAddr=i; delay(2);				//	Если на шине I2C есть устройство с адресом i, то используем этот адрес для проверки найденного модуля...
					if(_readBytes(REG_MODEL,4)											){										//	Читаем 4 байта начиная с регистра «REG_MODEL» в массив «data».
					if( data[0]     == DEF_MODEL_MOT									){										//	Если у модуля с адресом i в регистре «MODEL»   (data[0]) хранится значение DEF_MODEL_MOT, то ...
					if((data[2]>>1) == i                 || data[2] == 0xFF				){										//	Если у модуля с адресом i в регистре «ADDRESS» (data[2]) хранится значение i (адрес+младший бит) или 0xFF (адрес не задавался), то ...
					if( data[3]     == DEF_CHIP_ID_FLASH || data[3] == DEF_CHIP_ID_METRO){										//	Если у модуля с адресом i в регистре «CHIP_ID» (data[3]) хранится значение DEF_CHIP_ID_FLASH (идентификатор модулей Flash), или DEF_CHIP_ID_METRO (идентификатор модулей Metro), то ...
						valAddrTemp=i; i=128;																					//	Считаем что модуль обнаружен, сохраняем значение i как найденный адрес и выходим из цикла.
					}}}}}																										//
				}																												//
			}																													//
		//	Если модуль не найден, то возвращаем ошибку инициализации:															//
			if( valAddrTemp == 0														){	valAddr=0; return false;}			//
		//	Проверяем наличие модуля на шине I2C:																				//
			if( objI2C->checkAddress(valAddrTemp) == false								){	valAddr=0; return false;}			//	Если на шине I2C нет устройств с адресом valAddrTemp, то возвращаем ошибку инициализации
			valAddr=valAddrTemp;																								//	Сохраняем адрес модуля на шине I2C.
		//	Проверяем значения регистров модуля:																				//
			if(_readBytes(REG_MODEL,4)==false											){	valAddr=0; return false;}			//	Если не удалось прочитать 4 байта в массив «data» из модуля начиная с регистра «REG_MODEL», то возвращаем ошибку инициализации.
			if( data[0]     != DEF_MODEL_MOT											){	valAddr=0; return false;}			//	Если значение  регистра «MODEL»   (data[0]) не совпадает со значением DEF_MODEL_MOT, то возвращаем ошибку инициализации.
			if((data[2]>>1) != valAddrTemp       && data[2] !=0xFF						){	valAddr=0; return false;}			//	Если значение  регистра «ADDRESS» (data[2]) не совпадает с адресом модуля и не совпадает со значением 0xFF, то возвращаем ошибку инициализации.
			if( data[3]     != DEF_CHIP_ID_FLASH && data[3] != DEF_CHIP_ID_METRO		){	valAddr=0; return false;}			//	Если значение  регистра «CHIP_ID» (data[3]) не совпадает со значением DEF_CHIP_ID_FLASH и DEF_CHIP_ID_METRO, то возвращаем ошибку инициализации.
			valVers=data[1];																									//	Сохраняем байт регистра «VERSION» (data[1]) в переменую «valVers».
		//	Перезагружаем модуль устанавливая его регистры в значение по умолчанию:												//
			reset();																											//	Выполняем программную перезагрузку.
			delay(5);																											//
			return true;																										//	Возвращаем флаг успешной инициализаии.
}																																//
																																//
//		Перезагрузка модуля:																									//	Возвращаемое значение:	результат перезагрузки.
bool	iarduino_I2C_4LED::reset			(void){																				//	Параметр:				отсутствует.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Устанавливаем бит перезагрузки:																					//
				if(_readBytes(REG_BITS_0,1)==false){return false;}																//	Читаем 1 байт регистра «BITS_0» в массив «data».
				data[0] |= 0b10000000;																							//	Устанавливаем бит «SET_RESET»
				if(_writeBytes(REG_BITS_0,1)==false){return false;}																//	Записываем 1 байт в регистр «BITS_0» из массива «data».
			//	Ждём установки флага завершения перезагрузки:																	//
				do{ if(_readBytes(REG_FLAGS_0,1)==false){return false;} }														//	Читаем 1 байт регистра «REG_FLAGS_0» в массив «data».
				while( (data[0]&0b10000000) == 0);																				//	Повторяем чтение пока не установится флаг «FLG_RESET».
				return true;																									//
			}else{																												//	Иначе, если модуль не инициализирован, то ...
				return false;																									//	Возвращаем ошибку
			}																													//
}																																//
																																//
//		Смена адреса модуля:																									//	Возвращаемое значение:	резульат смены адреса.
bool	iarduino_I2C_4LED::changeAddress	(uint8_t newAddr){																	//	Параметр:				newAddr - новый адрес модуля (0x07 < адрес < 0x7F).
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Проверяем новый адрес:																							//
				if(newAddr>0x7F){newAddr>>=1;}																					//	Корректируем адрес, если он указан с учётом бита RW.
				if(newAddr==0x00 || newAddr==0x7F){return false;}																//	Запрещаем устанавливать адрес 0x00 и 0x7F.
			//	Записываем новый адрес:																							//
				if(_readBytes(REG_BITS_0,1)==false){return false;}																//	Читаем 1 байт регистра «BITS_0» в массив «data».
				data[0] |= 0b00000010;																							//	Устанавливаем бит «SAVE_ADR_EN»
				if(_writeBytes(REG_BITS_0,1)==false){return false;}																//	Записываем 1 байт в регистр «BITS_0» из массива «data».
				data[0] = (newAddr<<1)|0x01;																					//	Готовим новый адрес к записи в модуль, установив бит «SAVE_FLASH».
				if(_writeBytes(REG_ADDRESS,1)==false){return false;}															//	Записываем 1 байт в регистр «ADDRESS» из массива «data».
				delay(200);																										//	Даём более чем достаточное время для применения модулем нового адреса.
			//	Проверяем наличие модуля с новым адресом на шине I2C:															//
				if(objI2C->checkAddress(newAddr)==false){return false;}															//	Если на шине I2C нет модуля с адресом newAddr, то возвращаем ошибку.
				valAddr     = newAddr;																							//	Сохраняем новый адрес как текущий.
				valAddrTemp = newAddr;																							//	Сохраняем новый адрес как указанный.
				return true;																									//	Возвращаем флаг успеха.
			}else{																												//	Иначе, если модуль не инициализирован, то ...
				return false;																									//	Возвращаем ошибку
			}																													//
}																																//
																																//
//		Получение флага наличия подтяжки линий шины I2C:																		//	Возвращаемое значение:	флаг наличия подтяжки линий шины I2C.
bool	iarduino_I2C_4LED::getPullI2C		(void){																				//	Параметр:				отсутствует.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Считываем первые два регистра: регистр флагов и регистр битов:													//
				if(_readBytes(REG_FLAGS_0,2)==false ){ return false; }															//	Читаем 2 байта начиная с регистра «REG_FLAGS_0» в массив «data».
			//	Проверяем поддерживает ли модуль управление подтяжкой линий шины I2C:											//
				if( (data[0] & 0b00000100) == false ){ return false; }															//	Если флаг «FLG_I2C_UP» регистра «REG_FLAGS_0» сброшен, значит модуль не поддерживает управление подтяжкой линий шины I2C.
			//	Проверяем установлена ли подтяжка линий шины I2C:																//
				if( (data[1] & 0b00000100) == false ){ return false; }															//	Если бит  «SET_I2C_UP» регистра «REG_BITS_0»  сброшен, значит подтяжка линий шины I2C не установлена.
				return true;																									//	Возвращаем флаг успеха.
			}else{																												//	Иначе, если модуль не инициализирован, то ...
				return false;																									//	Возвращаем ошибку.
			}																													//
}																																//
																																//
//		Установка подтяжки линий шины I2C:																						//	Возвращаемое значение:	результат установки подтяжки линий шины I2C.
bool	iarduino_I2C_4LED::setPullI2C		(bool f){																			//	Параметр:				флаг подтяжки линий шины I2C.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Считываем первые два регистра: регистр флагов и регистр битов:													//
				if(_readBytes(REG_FLAGS_0,2)==false ){ return false; }															//	Читаем 2 байта начиная с регистра «REG_FLAGS_0» в массив «data».
			//	Проверяем поддерживает ли модуль управление подтяжкой линий шины I2C:											//
				if( (data[0] & 0b00000100) == false ){ return false; }															//	Если флаг «FLG_I2C_UP» регистра «REG_FLAGS_0» сброшен, значит модуль не поддерживает управление подтяжкой линий шины I2C.
			//	Устанавливаем или сбрасываем бит включения подтяжки линий шины I2C:												//
				if(f){ data[0] = (data[1] |  0b00000100); }																		//	Если флаг «f» установлен, то копируем значение из 1 в 0 элемент массива «data» установив бит «SET_I2C_UP».
				else { data[0] = (data[1] & ~0b00000100); }																		//	Если флаг «f» сброшен   , то копируем значение из 1 в 0 элемент массива «data» сбросив   бит «SET_I2C_UP».
			//	Сохраняем получившееся значение в регистр «REG_BITS_0»:															//
				if(_writeBytes(REG_BITS_0,1)==false ){ return false; }															//	Записываем 1 байт в регистр «REG_BITS_0» из массива «data».
				return true;																									//	Возвращаем флаг успеха.
			}else{																												//	Иначе, если модуль не инициализирован, то ...
				return false;																									//	Возвращаем ошибку
			}																													//
}																																//
																																//
//		Установка схемы включения светодиодов:																					//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_4LED::scheme			(uint8_t var){																		//	Параметр:				схема включения LED_CA (ОА) или LED_CC (ОК).
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Проверяем полученные данные:																					//
				if( (var!=LED_CA) && (var!=LED_CC) ){ return; }																	//	Нет схем кроме общего анода и общего катода.
			//	Считываем текущее состояние битов регистра «REG_4LED_FLG»:														//
				if(_readBytes(REG_4LED_FLG,1)==false ){ return; }																//	Читаем 1 байт из регистра «REG_4LED_FLG» в массив «data».
			//	Готовим байт для записи:																						//
				data[0] &= LED_BIT_TURN;																						//	Оставляем только значение флага переворота изображения «LED_BIT_TURN».
				data[0] |= var;																									//	Добавляем биты из переменной «var».
			//	Отправляем подготовленные данные в модуль:																		//
				_writeBytes(REG_4LED_FLG, 1);																					//	Записываем 1 байт из массива «data» в регистр «REG_4LED_FLG».
			}																													//
}																																//
																																//
//		Установка частоты обновления всего изображения индикатора:																//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_4LED::fps				(uint8_t frequency){																//	Параметр:				частота в Гц (1-255).
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Готовим байт для записи:																						//
				data[0] = frequency;																							//	Сохраняем значение «frequency» в 0 элемент массива «data».
			//	Отправляем подготовленные данные в модуль:																		//
				_writeBytes(REG_4LED_FREQUENCY, 1);																				//	Записываем 1 байт из массива «data» в регистр «REG_4LED_FREQUENCY».
			}																													//
}																																//
																																//
//		Установка яркости:																										//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_4LED::light			(uint8_t volume){																	//	Параметр:				яркость от 0 до 7.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Проверяем полученные данные:																					//
				if( volume > 7 ){ volume = 7; }																					//	Яркость не может быть выше 7.
			//	Готовим байт для записи:																						//
				if( volume == 0 ){ data[0] =  0 << 3; }																			//	Определяем значение 0 элемента массива «data».
				if( volume == 1 ){ data[0] =  1 << 3; }																			//	Определяем значение 0 элемента массива «data».
				if( volume == 2 ){ data[0] =  2 << 3; }																			//	Определяем значение 0 элемента массива «data».
				if( volume == 3 ){ data[0] =  4 << 3; }																			//	Определяем значение 0 элемента массива «data».
				if( volume == 4 ){ data[0] =  8 << 3; }																			//	Определяем значение 0 элемента массива «data».
				if( volume == 5 ){ data[0] = 14 << 3; }																			//	Определяем значение 0 элемента массива «data».
				if( volume == 6 ){ data[0] = 22 << 3; }																			//	Определяем значение 0 элемента массива «data».
				if( volume == 7 ){ data[0] = 31 << 3; }																			//	Определяем значение 0 элемента массива «data».
			//	Отправляем подготовленные данные в модуль:																		//
				_writeBytes(REG_4LED_BRIGHTNESS, 1);																			//	Записываем 1 байт из массива «data» в регистр «REG_4LED_BRIGHTNESS».
			}																													//
}																																//
																																//
//		Разворот изображения на 180°:																							//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_4LED::turn(bool flg){																						//	Параметр:				флаг разворота.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Готовим байт для записи:																						//
				data[0] = flg? LED_BIT_TURN:0;																					//	Определяем значение бита «LED_BIT_TURN» в 0 элементе массива «data».
			//	Отправляем подготовленные данные в модуль:																		//
				_writeBytes(REG_4LED_FLG, 1);																					//	Записываем 1 байт из массива «data» в регистр «REG_4LED_FLG».
			}																													//
}																																//
																																//
//		Установка точек:																										//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_4LED::point(uint8_t pos,bool flg){																			//	Параметры:				ПОЗИЦИЯ от 1 до 4 или 0 для двоеточия, СОСТОЯНИЕ 0/1
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Готовим данные для записи:																						//
				if(pos==0||pos>4){arrString[4]=flg?':':' ';}																	//	Сохраняем двоеточие             в строку «arrString».
				if(pos==1||pos>4){arrString[1]=flg?'.':' ';}																	//	Сохраняем точку после 1 символа в строку «arrString».
				if(pos==2||pos>4){arrString[3]=flg?'.':' ';}																	//	Сохраняем точку после 2 символа в строку «arrString».
				if(pos==3||pos>4){arrString[6]=flg?'.':' ';}																	//	Сохраняем точку после 3 символа в строку «arrString».
				if(pos==4||pos>4){arrString[8]=flg?'.':' ';}																	//	Сохраняем точку после 4 символа в строку «arrString».
			//	Отправляем подготовленные данные в модуль:																		//
				_writeData();																									//	Выводим строку «arrString» на дисплей.
			}																													//
}																																//
																																//
//		Установка миганий разрядов:																								//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_4LED::blink(uint8_t pos,bool flg){																			//	Параметры:				ПОЗИЦИЯ от 1 до 4 или 0 для двоеточия, СОСТОЯНИЕ 0/1
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Считываем текущее состояние битов регистра «REG_4LED_BLINK»:													//
				if(_readBytes(REG_4LED_BLINK,1)==false ){ return; }																//	Читаем 1 байт из регистра «REG_4LED_BLINK» в массив «data».
			//	Готовим байт для записи:																						//
				if(pos==0||pos>4){ if(flg){data[0]|=LED_BIT_DEG4;}else{data[0]&=~LED_BIT_DEG4;} }								//	Сохраняем состояние для двоеточия.
				if(pos==1||pos>4){ if(flg){data[0]|=LED_BIT_DEG0;}else{data[0]&=~LED_BIT_DEG0;} }								//	Сохраняем состояние для 1 символа.
				if(pos==2||pos>4){ if(flg){data[0]|=LED_BIT_DEG1;}else{data[0]&=~LED_BIT_DEG1;} }								//	Сохраняем состояние для 2 символа.
				if(pos==3||pos>4){ if(flg){data[0]|=LED_BIT_DEG2;}else{data[0]&=~LED_BIT_DEG2;} }								//	Сохраняем состояние для 3 символа.
				if(pos==4||pos>4){ if(flg){data[0]|=LED_BIT_DEG3;}else{data[0]&=~LED_BIT_DEG3;} }								//	Сохраняем состояние для 4 символа.
			//	Отправляем подготовленные данные в модуль:																		//
				_writeBytes(REG_4LED_BLINK, 1);																					//	Записываем 1 байт из массива «data» в регистр «REG_4LED_BLINK».
			}																													//
}																																//
																																//
//		Установка частоты миганий разрядов:																						//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_4LED::frequ(uint8_t frequency){																			//	Параметр:				ЧАСТОТА от 1 до 4 Гц.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Проверяем полученные данные:																					//
				if( frequency < 1 ){ frequency = 1; }																			//	Частота не может быть ниже 1 Гц.
				if( frequency > 4 ){ frequency = 4; }																			//	Частота не может быть выше 4 Гц.
			//	Считываем текущее состояние битов регистра «REG_4LED_BLINK»:													//
				if(_readBytes(REG_4LED_BLINK,1)==false ){ return; }																//	Читаем 1 байт из регистра «REG_4LED_BLINK» в массив «data».
			//	Готовим байт для записи:																						//
				data[0] &= ~LED_BIT_FREQUENCY;																					//	Сбрасываем значение битов «LED_BIT_FREQUENCY».
				data[0] |= ((frequency-1) << 6);																				//
			//	Отправляем подготовленные данные в модуль:																		//
				_writeBytes(REG_4LED_BLINK, 1);																					//	Записываем 1 байт из массива «data» в регистр «REG_4LED_BLINK».
			}																													//
}																																//
																																//
//		Установка светодиодов по битам:																							//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_4LED::setLED(uint8_t a, uint8_t b, uint8_t c, uint8_t d, bool f){											//	Параметры:				байт битов 1 разряда, байт битов 2 разряда, байт битов 3 разряда, байт битов 4 разряда, флаг двоеточия.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Готовим данные для записи:																						//
				data[0]=((a&128)?1:0)|((a&64)?2:0)|((a&32)?4:0)|((a&16)?8:0)|((a&8)?16:0)|((a&4)?32:0)|((a&2)?64:0)|((a&1)?128:0);//	Сохраняем значение для 1 сегмента в 0 элемент массива «data».
				data[1]=((b&128)?1:0)|((b&64)?2:0)|((b&32)?4:0)|((b&16)?8:0)|((b&8)?16:0)|((b&4)?32:0)|((b&2)?64:0)|((b&1)?128:0);//	Сохраняем значение для 2 сегмента в 1 элемент массива «data».
				data[2]=((c&128)?1:0)|((c&64)?2:0)|((c&32)?4:0)|((c&16)?8:0)|((c&8)?16:0)|((c&4)?32:0)|((c&2)?64:0)|((c&1)?128:0);//	Сохраняем значение для 3 сегмента в 2 элемент массива «data».
				data[3]=((d&128)?1:0)|((d&64)?2:0)|((d&32)?4:0)|((d&16)?8:0)|((d&8)?16:0)|((d&4)?32:0)|((d&2)?64:0)|((d&1)?128:0);//	Сохраняем значение для 4 сегмента в 3 элемент массива «data».
				data[4]=((f    )?3:0);																							//	Сохраняем значение для двоеточия  в 4 элемент массива «data».
			//	Запрещаем дублированную запись:																					//
				if(memcmp(dataTemp,data,5)){memcpy(dataTemp,data,5);}else{return;}												//	Запрещаем записывать данные если они уже записаны.
			//	Отправляем подготовленные данные в модуль:																		//
				_writeBytes(REG_4LED_DEG, 5);																					//	Записываем 5 байт массива «data» в модуль начиная с регистра «REG_4LED_DEG».
			}																													//
}																																//
																																//
//		Вывод одного разряда на дисплей:																						//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_4LED::_writeData(uint8_t deg, uint8_t pos){																//	Параметры:				deg - байт битов разряда, pos - позиция разряда.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Проверяем полученные данные:																					//
				if( pos > 4 ){ return; }																						//	Позиция сегмента может принимать значение от 0 (старший разряд) до 4 (двоеточие).
			//	Готовим байт для записи:																						//
				data[0] = deg;																									//	Сохраняем значение «deg» в 0 элемент массива «data».
			//	Запрещаем дублированную запись:																					//
				if(dataTemp[pos]!=data[0]){dataTemp[pos]=data[0];}else{return;}													//	Запрещаем записывать данные если они уже записаны.
			//	Отправляем подготовленные данные в модуль:																		//
				_writeBytes(REG_4LED_DEG+pos, 1);																				//	Записываем 1 байт из массива «data» в регистр «REG_4LED_DEG»+«pos».
			}																													//
}																																//
																																//
//		Вывод строки «arrString» на на дисплей:																					//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_4LED::_writeData(){																						//	Параметр:				отсутствует. Используется строка массива «arrString» = "X.X.:X.X.".
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Готовим данные для записи:																						//
				data[0] = _codeSymbol(arrString[0]) | (arrString[1]==' '?0:1);													//	Сохраняем значение для 1 сегмента «arrString[0]» и его точки «arrString[1]» в 0 элемент массива «data».
				data[1] = _codeSymbol(arrString[2]) | (arrString[3]==' '?0:1);													//	Сохраняем значение для 2 сегмента «arrString[2]» и его точки «arrString[3]» в 1 элемент массива «data».
				data[2] = _codeSymbol(arrString[5]) | (arrString[6]==' '?0:1);													//	Сохраняем значение для 3 сегмента «arrString[5]» и его точки «arrString[6]» в 2 элемент массива «data».
				data[3] = _codeSymbol(arrString[7]) | (arrString[8]==' '?0:1);													//	Сохраняем значение для 4 сегмента «arrString[7]» и его точки «arrString[8]» в 3 элемент массива «data».
				data[4] =                             (arrString[4]==' '?0:3);													//	Сохраняем значение для двоеточия  «arrString[4]»                             в 4 элемент массива «data».
			//	Запрещаем дублированную запись:																					//
				if(memcmp(dataTemp,data,5)){memcpy(dataTemp,data,5);}else{return;}												//	Запрещаем записывать данные если они уже записаны.
			//	Отправляем подготовленные данные в модуль:																		//
				_writeBytes(REG_4LED_DEG, 5);																					//	Записываем 5 байт массива «data» в модуль начиная с регистра «REG_4LED_DEG».
			}																													//
}																																//
																																//
//		Кодирование символа в семисегментный вид:																				//	Возвращаемое значение:	байт битов.
uint8_t	iarduino_I2C_4LED::_codeSymbol(char sym){																				//	Параметр:				символ.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
				switch(sym){																									//	 abcdefgh
					case 'o': case 'O': case '0':	return 0xFC;	break;														//	B11111100
					case 'i': case 'I': case '1':	return 0x60;	break;														//	B01100000
										case '2':	return 0xDA;	break;														//	B11011010
										case '3':	return 0xF2;	break;														//	B11110010
										case '4':	return 0x66;	break;														//	B01100110
					case 's': case 'S':	case '5':	return 0xB6;	break;														//	B10110110
										case '6':	return 0xBE;	break;														//	B10111110
										case '7':	return 0xE0;	break;														//	B11100000
										case '8':	return 0xFE;	break;														//	B11111110
										case '9':	return 0xF6;	break;														//	B11110110
					case 'a': case 'A':				return 0xEE;	break;														//	B11101110
					case 'b': case 'B':				return 0x3E;	break;														//	B00111110
					case 'c': case 'C':				return 0x9C;	break;														//	B10011100
					case 'd': case 'D':				return 0x7A;	break;														//	B01111010
					case 'e': case 'E':				return 0x9E;	break;														//	B10011110
					case 'f': case 'F':				return 0x8E;	break;														//	B10001110
					case 'g': case 'G':				return 0xBC;	break;														//	B10111100
					case 'h': case 'H':				return 0x9E;	break;														//	B01101110
					case 'j': case 'J':				return 0x78;	break;														//	B01111000
					case 'l': case 'L':				return 0x1C;	break;														//	B00011100
					case 'n': case 'N':				return 0x2A;	break;														//	B00101010
					case 'p': case 'P':				return 0xCE;	break;														//	B11001110
					case 't': case 'T':				return 0x1E;	break;														//	B00011110
					case 'u': case 'U':				return 0x7C;	break;														//	B01111100
					case '-':						return 0x02;	break;														//	B00000010
					case '_':						return 0x10;	break;														//	B00010000
					case '*':						return 0xC6;	break;														//	B11000110
					case '"': case '\'':			return 0x44;	break;														//	B01000100
					default :						return 0x00;	break;														//	B00000000
			}	}									return 0x00;																//	B00000000
}																																//
																																//
//		Сортировка параметров вывода:																							//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_4LED::_sortStyle(char j0, uint8_t j1, uint8_t j2, uint8_t j3, uint8_t j4, uint8_t j5){						//	Параметры:				символ, параметр1, параметр2, параметр3, параметр4, параметр5.
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Собираем все полученные параметры в массив:																		//
				uint8_t j[5]={j1,j2,j3,j4,j5};																					//	Определяем массив полученными параметрами.
			//	Сбрасываем переменные для хранения параметров в значения по умолчанию:											//
				symZero=j0;																										//	' '                   символ заменяющий знаки 0 перед числом (если «varLen» больше разрядности числа).
				varLen=255;																										//	0,1,2,3,4,255         длинна (количество рязрядов) выводимого числа, 255-по размеру числа.
				valPos=255;																										//	POS1 - POS4           позиция (номер разряда) выводимого числа.
				valDir=LEFT;																									//	LEFT / RIGHT          направление сдвига от указанной позиции.
				valType=DEC;																									//	DEC/HEX/TIME/TEMP     тип выводимого числа.
				valPart=255;																									//	0,1,2,3,4,255         количество знаков после запятой, 255-не указано.
				arrString[0]=0;																									//	"X.X.:X.X."           строка символов для вывода на экран.
			//	Находим тип выводимого числа «valType»:																			//
				for( uint8_t i=0; i<5; i++ ){ if(j[i]==DEC  || j[i]==HEX  || j[i]==TIME || j[i]==TEMP){valType=j[i];} }			//
			//	Находим длину «varLen», позицию «valPos», направление «valDir» и количество знаков после запятой «valPart»:		//
				for( uint8_t i=valType==TIME?1:0; i<5; i++ ){																	//	Проходим по всем полученным параметрам ...
					if( j[i]==LEN1 || j[i]==LEN2 || j[i]==LEN3 || j[i]==LEN4 ){ varLen=j[i]; }									//	Определяем длину (количество рязрядов) «varLen» выводимого числа.
					if( j[i]==POS1 || j[i]==POS2 || j[i]==POS3 || j[i]==POS4 ){ valPos=j[i]; }									//	Определяем позицию (номер разряда) «valPos» выводимого числа.
					if( j[i]==LEFT || j[i]==RIGHT                            ){ valDir=j[i]; }									//	Определяем направление сдвига «valDir» от позиции «valPos».
				}	if( j1<5                                                 ){ valPart=j1 ; }									//	Определяем количество знаков после запятой «valPart».
				if( valPos==255 ){ valPos = valDir==LEFT? POS4:POS1; }															//	Определяем позицию (номер разряда) «valPos» выводимого числа если она не указана.
			}																													//
}																																//
																																//
//		Вывод целого числа:																										//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_4LED::_printNumI(int16_t i){																				//
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Перенапраяляем вывод на число с плавающей точкой:																//
				if(valPart>0 && valPart!=255){_printNumF(double(i)); return;}													//
			//	Создаём временные переменные:																					//
				char l[10]; l[0]=0; uint8_t len=0; bool neg=0, fneg=0;															//
			//	Сохраняем знак и получаем модуль числа i:																		//
				if(i<0){neg=1; fneg=1; i*=-1;}																					//
			//	Преобразуем число i в строку l и определяем её длину len:														//
				itoa(i,l,(valType==HEX?HEX:DEC)); if(valType==TEMP){strcat(l,"*");} len=strlen(l);								//
			//	Удаляем из начала строки l лишние символы, если таковые есть:													//
				if(varLen<255 && (varLen-LEN1+1)<len){_strDelete(l,(len-(varLen-LEN1+1)),0);} len=strlen(l);					//
			//	Добавляем в начало строки l недостающие символы '0' и знак числа, если таковые необходимы:						//
				if(varLen<255 && (varLen-LEN1+1)>len){_strInsert(l,symZero,((varLen-LEN1)-len),0); _strInsert(l,(neg?'-':symZero),1,0); fneg=0;} len=strlen(l);
			//	Если в предыдущем условии знак не добавлен, то добавляем его сейчас:											//
				if(fneg){if(varLen<255 && (varLen-LEN1)<len){_strDelete(l,1,0);} _strInsert(l,'-',1,0); fneg=0;} len=strlen(l);	//
			//	Сдвигаем строку l вправо на указанную в valPos позицию:															//
				if(valPos>POS1){_strInsert(l,' ',(valPos-POS1),0);}																//
			//	Сдвигаем строку влево если указано смещение valDir==LEFT:														//
				if(valDir==LEFT){_strDelete(l,len-1,0);} len=strlen(l);															//
			//	Срезаем символы за пределами индикатора:																		//
				l[4]=0;																											//
			//	Выводим строку:																									//
				_printNumS(l);																									//
			}																													//
}																																//
																																//
//		Вывод числа с плавающей точкой:																							//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_4LED::_printNumF(double i){																				//
			if(valAddr){																										//	Если модуль был инициализирован, то ...
			//	Перенапраяляем вывод на число без запятой:																		//
				if(valPart==0){_printNumI(int16_t(i)); return;} if(valPart==255){valPart=1;} if(valPart>4){valPart=4;}			//
			//	Создаём временные переменные:																					//
				char l[10]; l[0]=0; uint8_t len=0; bool neg=0, fneg=0, fneg1=0;													//
			//	Сохраняем знак и получаем модуль числа i:																		//
				if(i<0){neg=1; fneg=1; fneg1=1; i*=-1;}																			//
			//	Разбиваем число на челое и дробное:																				//
				int16_t i1 = int16_t(i);																						//
				int16_t i2 = int32_t(i*10000)%10000;																			//
			//	Собираем целое i1 и дробное i2 в строку l и определяем её длину len:											//
				itoa(i1,l,(valType==HEX?HEX:DEC)); strcat(l,"."); len=strlen(l); if(i2<1000){strcat(l,"0");} if(i2<100){strcat(l,"0");} if(i2<10){strcat(l,"0");} itoa(i2,&l[strlen(l)],(valType==HEX?HEX:DEC)); l[len+valPart]=0; if(valType==TEMP){strcat(l,"*");} len=strlen(l);
			//	Удаляем из начала строки l лишние символы, если таковые есть:													//
				if(varLen<255 && (varLen-LEN1+2)<len){_strDelete(l,(len-(varLen-LEN1+2)),0);} len=strlen(l);					//
			//	Добавляем в начало строки l недостающие символы '0' и знак числа, если таковые необходимы:						//
				if(varLen<255 && (varLen-LEN1+2)>len){_strInsert(l,symZero,((varLen-LEN1+1)-len),0); _strInsert(l,(neg?'-':symZero),1,0); fneg=0;} len=strlen(l);
			//	Если в предыдущем условии знак не добавлен, то добавляем его сейчас:											//
				if(fneg){if(varLen<255 && (varLen-LEN1+1)<len){_strDelete(l,1,0);} _strInsert(l,'-',1,0); fneg=0;} len=strlen(l);
			//	Сдвигаем строку l вправо на указанную в valPos позицию:															//
				if(valPos>POS1){_strInsert(l,' ',(valPos-POS1),0);}																//
			//	Сдвигаем строку влево если указано смещение valDir==LEFT:														//
				if(valDir==LEFT){_strDelete(l,len-2,0);} len=strlen(l);															//
			//	Проверка наличия запятых и знаков:																				//
				if(l[0]=='.'){_strDelete(l,1,0);}																				//
				fneg=1; if(l[1]=='.'){fneg=0;} if(l[2]=='.'){fneg=0;} if(l[3]=='.'){fneg=0;} if(l[4]=='.'){fneg=0;} if(fneg){_strDelete(l,1,0);} if(l[0]=='.'){_strDelete(l,1,0);}
				fneg=1; if(l[0]=='-'){fneg=0;} if(l[1]=='-'){fneg=0;} if(l[2]=='-'){fneg=0;} if(l[3]=='-'){fneg=0;} if(l[4]=='-'){fneg=0;} if(fneg && fneg1){l[0]='-';}
				fneg=0; if(l[1]=='.'){fneg=1;} if(l[2]=='.'){fneg=1;} if(l[3]=='.'){fneg=1;} if(l[4]=='.'){fneg=1;} l[4+fneg]=0;//
			//	Выводим строку:																									//
				_printNumS(l);																									//
			}																													//
}																																//
																																//
//		Вывод времени:																											//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_4LED::_printNumT(uint8_t i, uint8_t j){																	//
			if(valAddr){																										//	Если модуль был инициализирован, то ...
				char l[10]; l[0]=0;																								//
				if(i>59){i=59;} if(j>59){j=59;}																					//
				if(i<10){strcat(l,"0");}																						//	Добавляем символ 0 перед часами, если таковой нужен.
				itoa(i,&l[strlen(l)],DEC);																						//	Добавляем в строку часы.
				strcat(l,":");																									//	Добавляем в строку разделитель.
				if(j<10){strcat(l,"0");}																						//	Добавляем символ 0 перед минутами, если таковой нужен.
				itoa(j,&l[strlen(l)],DEC);																						//	Добавляем в строку часы.
			//	Выводим строку:																									//
				_printNumS(l);																									//
			}																													//
}																																//
																																//
//		Вывод строки:																											//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_4LED::_printNumS(const char *i){																					//
			if(valAddr){																										//	Если модуль был инициализирован, то ...
				uint8_t f=0;																									//
				arrString[0]=0;																									//	Чистим строку «arrString».
				for(uint8_t j=0, k=1; j<10; j++, k++){																			//	Проходим по всем доступным символам строки «i».
					if(strlen(i)>j){																							//
						if(i[j]==':'||i[j]==';'||i[j]=='='){f=k; k--;}else														//
						{																										//
							if(i[j]=='.' || i[j]==',')	{if(k%2==1){if(k<10){arrString[k-1]=' ';} k++;}}						//	Если требуется вывести "." или ":".
							else						{if(k%2==0){if(k<10){arrString[k-1]=' ';} k++;}}						//	Если требуется вывести число.
							if(k<10){arrString[k-1]=i[j];}																		//	Дополняем строку указанным символом.
						}																										//
					}else{	if(k<10){arrString[k-1]=' ';}}																		//	Дополняем недостающие символы.
				}	arrString[9]=0;																								//
				if(f==1)		{arrString[5]=0;	_strInsert(arrString,' ',4,0);}												//
				if(f==2 || f==3){arrString[7]=0;	_strInsert(arrString,' ',2,0);}												//
				if(f==6 || f==7){					_strDelete(arrString,    2,0);}												//
				if(f==8 || f==9){					_strDelete(arrString,    4,0);}												//
													_strInsert(arrString,(f>0?':':' '),1,4);									//
				for(uint8_t j=0; j<9; j++){if(arrString[j]==0){arrString[j]=' ';}} arrString[9]=0;								//
				_writeData();																									//	Выводим строку «arrString» на на дисплей.
			}																													//
}																																//
																																//
//		Вывод массива:																											//	Возвращаемое значение:	отсутствует.
void	iarduino_I2C_4LED::_printNumA(int i[]){																					//
			if(valAddr){																										//	Если модуль был инициализирован, то ...
				for(uint8_t j=0; j<9; j++){arrString[j]=' ';} arrString[9]=0;													//
				if(i[0]<=16){itoa(i[0], &arrString[0], HEX);}else{arrString[0]=' ';} arrString[1]=' ';							//
				if(i[1]<=16){itoa(i[1], &arrString[2], HEX);}else{arrString[2]=' ';} arrString[3]=' '; arrString[4]=' ';		//
				if(i[2]<=16){itoa(i[2], &arrString[5], HEX);}else{arrString[5]=' ';} arrString[6]=' ';							//
				if(i[3]<=16){itoa(i[3], &arrString[7], HEX);}else{arrString[7]=' ';} arrString[8]=' '; arrString[9]=0;			//
				_writeData();																									//	Выводим строку «arrString» на на дисплей.
			}																													//
}																																//
																																//
//		функции обработки строк:																								//
void	iarduino_I2C_4LED::_strInsert(char *i, char j, int n, int k){															//	вставить символ j в строку i, n раз, начиная с позиции k
			if(n<0 || k<0){return;} for(uint8_t l=0; l<n; l++){for(uint8_t m=strlen(i)+1; m>k; m--){i[m]=i[m-1];} i[k]=j;}		//
}																																//
void	iarduino_I2C_4LED::_strDelete(char *i, int n, int k){																	//	удалить n символов из строки i начиная с позиции k
			if(n<0 || k<0){return;} for(uint8_t l=0; l<n; l++){for(uint8_t m=k; m<=strlen(i); m++){i[m]=i[m+1];}}				//
}																																//
																																//
//		Чтение данных из регистров в массив data:																				//	Возвращаемое значение:	результат чтения (true/false).
bool	iarduino_I2C_4LED::_readBytes		(uint8_t reg, uint8_t sum){															//	Параметры:				reg - номер первого регистра, sum - количество читаемых байт.
			bool	result=false;																								//	Определяем флаг       для хранения результата чтения.
			uint8_t	sumtry=10;																									//	Определяем переменную для подсчёта количества оставшихся попыток чтения.
			do{	result = objI2C->readBytes(valAddr, reg, data, sum);															//	Считываем из модуля valAddr, начиная с регистра reg, в массив data, sum байт.
				sumtry--;	if(!result){delay(1);}																				//	Уменьшаем количество попыток чтения и устанавливаем задержку при неудаче.
			}	while		(!result && sumtry>0);																				//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
			delayMicroseconds(500);																								//	Между пакетами необходимо выдерживать паузу.
			return result;																										//	Возвращаем результат чтения (true/false).
}																																//
																																//
//		Запись данных в регистры из массива data:																				//	Возвращаемое значение:	результат записи (true/false).
bool	iarduino_I2C_4LED::_writeBytes	(uint8_t reg, uint8_t sum, uint8_t num){												//	Параметры:				reg - номер первого регистра, sum - количество записываемых байт, num - номер первого элемента массива data.
			bool	result=false;																								//	Определяем флаг       для хранения результата записи.
			uint8_t	sumtry=10;																									//	Определяем переменную для подсчёта количества оставшихся попыток записи.
			do{	result = objI2C->writeBytes(valAddr, reg, &data[num], sum);														//	Записываем в модуль valAddr начиная с регистра reg, sum байи из массива data начиная с элемента num.
				sumtry--;	if(!result){delay(1);}																				//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
			}	while		(!result && sumtry>0);																				//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
			delay(10);																											//	Ждём применения модулем записанных данных.
			return result;																										//	Возвращаем результат записи (true/false).
}																																//
																																//
